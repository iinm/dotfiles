#!/usr/bin/env bash

set -eu -o pipefail

SCRIPT_VERSION="0.0.10"

SCRIPT_PATH=$(readlink -f "${BASH_SOURCE[0]}")
SCRIPT_NAME=$(basename "${BASH_SOURCE[0]}")

MOUNTABLE_SCRIPT_PATH="$HOME/.cache/$SCRIPT_NAME/$SCRIPT_NAME"
CONTAINER_SCRIPT_PATH="/sandbox/bin/$SCRIPT_NAME"

help() {
  cat << HELP
$SCRIPT_NAME v$SCRIPT_VERSION - Run a command in a sandboxed Docker environment

Usage: $SCRIPT_NAME [--dockerfile FILE]
           [--platform PLATFORM]
           [--env-file FILE]
           [--allow-write] [--allow-net [DESTINATIONS|--]]
           [--volume [NAME:]CONTAINER_DIR]
           [--mount-writable HOST_DIR:CONTAINER_DIR] [--mount-readonly HOST_DIR:CONTAINER_DIR]
           [--publish [HOST_ADDRESS:]HOST_PORT:CONTAINER_PORT]
           [--tty]
           [--no-cache]
           [--verbose] [--dry-run]
           COMMAND


Options:

  --dockerfile FILE         Path to a Dockerfile. If not set, a preset Dockerfile and network policy is used.
                            The container must include busybox, bash, iptables, ipset, dnsmasq, and dig commands.
  --env-file FILE           Path to a .env file to load environment variables from.
  --platform                Specify the platform for image building and container execution
                            (e.g., linux/arm64 or linux/amd64).
  --allow-write             Allow write access to the project root inside the container.
                            By default, the project root (git root or current directory) is read-only.
  --allow-net DESTINATIONS  Allow connections to specified domains or IP addresses.
                            Separate multiple destinations with commas.
                            If no port is given, only HTTPS (443) is allowed.
  --volume [NAME:]CONTAINER_DIR
                            Mount a writable Docker volume to a container path.
                            If NAME is not given, the volume name is generated.
  --mount-readonly HOST_DIR:CONTAINER_DIR
                            Mount a host file or directory to a container path as read-only.
  --mount-writable HOST_DIR:CONTAINER_DIR
                            Mount a host file or directory to a container path as writable.
  --publish [HOST_ADDRESS:]HOST_PORT:CONTAINER_PORT
                            Publish container port(s) to the host.
                            If no host address is given, ports bind to 127.0.0.1 by default.
  --tty                     Allocate a pseudo-TTY for the container.
  --no-cache                Don't use cache when building the image.
  --verbose                 Output verbose logs to stderr.
  --dry-run                 Don't execute the command; just print it to stdout.


Examples:

  Start shell with preset configuration:
    $SCRIPT_NAME --tty --verbose zsh

  Check preset configuration:
    $SCRIPT_NAME --tty --verbose --dry-run zsh

  Start Claude Code:
    $SCRIPT_NAME --allow-write --allow-net --mount-writable ~/.claude:/home/sandbox/.claude,~/.claude.json:/home/sandbox/.claude.json --tty --verbose claude

  Start Codex CLI:
    bash -c 'read -sp "Input OpenAI API Key: " OPENAI_API_KEY; echo "OPENAI_API_KEY=\$OPENAI_API_KEY" >> .env.sandbox'
    $SCRIPT_NAME --env-file .env.sandbox --allow-write --allow-net --mount-writable ~/.codex:/home/sandbox/.codex --tty --verbose codex

  Start Gemini CLI:
    bash -c 'read -sp "Input Gemini API Key: " GEMINI_API_KEY; echo "GEMINI_API_KEY=\$GEMINI_API_KEY" >> .env.sandbox'
    $SCRIPT_NAME --env-file .env.sandbox --allow-write --allow-net --mount-writable ~/.gemini:/home/sandbox/.gemini --tty --verbose gemini

  Install tools with mise:
    $SCRIPT_NAME --allow-net nodejs.org --tty --verbose mise install node
    $SCRIPT_NAME --allow-net github.com,dl.google.com --tty --verbose mise install go

  Run with Dockerfile:
    $SCRIPT_NAME --dockerfile Dockerfile.minimum --tty --verbose bash

  Allow access to docker host:
    $SCRIPT_NAME --dockerfile Dockerfile.minimum --allow-net host.docker.internal:3000 --verbose busybox nc host.docker.internal 3000 < /dev/null


Preset Configuration:

  When --dockerfile is not specified, a preset Debian 12 image is used with:
  - System packages: busybox, bash, zsh (with grml config), ripgrep, fd, dig, curl, wget, git
  - Node.js v22.17.1 with npm
  - mise-en-place package manager for additional runtime installations
  - AI coding assistants: Claude Code, Gemini CLI, Codex CLI
  - Persistent storage for shell history, git config, and AI tool configurations
  - Default editor: busybox vi
  - Pre-allowed network access for mise and coding agents (mise-versions.jdx.dev, api.anthropic.com, generativelanguage.googleapis.com, api.openai.com, etc.)


How to view DNS query log:

  DNS queries are logged by dnsmasq and can only be viewed through Docker logs.
  
  Find the container name:
  docker ps | grep $SCRIPT_NAME
  
  View DNS query logs in real-time
  docker logs -f <container-name>
HELP
}

print_preset_dockerfile() {
  cat << 'EOF'
FROM debian:12

ARG NODE_VERSION="22.17.1"

RUN apt update && apt install -y \
      busybox \
      bash zsh \
      ripgrep fd-find \
      iptables ipset dnsmasq dnsutils \
      curl wget \
      git gpg locales \
    && bash -c '$(which fdfind) /usr/local/bin/fd' \
    && echo 'en_US.UTF-8 UTF-8' >> /etc/locale.gen \
    && echo 'ja_JP.UTF-8 UTF-8' >> /etc/locale.gen \
    && locale-gen 

ENV LANG=en_US.UTF-8

# grml zsh config: https://grml.org/zsh/
RUN curl -fsSL https://grml.org/console/zshrc -o /etc/skel/.zshrc \
    && curl -fsSL https://grml.org/console/zshrc.local -o /etc/skel/.zshrc.local \
    && echo 'unsetopt HIST_SAVE_BY_COPY' >> /etc/skel/.zshrc.local

# mise-en-place: https://mise.jdx.dev/
RUN install -dm 755 /etc/apt/keyrings \
    && wget -qO - https://mise.jdx.dev/gpg-key.pub | gpg --dearmor | tee /etc/apt/keyrings/mise-archive-keyring.gpg 1> /dev/null \
    && echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.gpg arch=$(dpkg --print-architecture)] https://mise.jdx.dev/deb stable main" | tee /etc/apt/sources.list.d/mise.list \
    && apt update \
    && apt install -y mise \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.bashrc \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.zshrc

# Create user
RUN groupadd sandbox \
    && useradd -g sandbox -m sandbox \
    && mkdir -p /sandbox/tools && chown sandbox:sandbox /sandbox/tools

USER sandbox

# Install Node.js
RUN curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-$(uname -m | sed 's,x86_64,x64,; s,aarch64,arm64,').tar.xz" | busybox xz -dc | tar -C /sandbox/tools -xf - \
    && mv /sandbox/tools/node-v${NODE_VERSION}* /sandbox/tools/node \
    && env PATH=/sandbox/tools/node/bin:$PATH npm install -g npm@latest
ENV PATH=/sandbox/tools/node/bin:$PATH

# Install coding agents
RUN npm install -g @anthropic-ai/claude-code \
    && npm install -g @google/gemini-cli \
    && npm install -g @openai/codex \
    && rm -rf /home/sandbox/.npm

RUN echo 'test -L ~/.bash_history || (touch /persistent/home/.bash_history; ln -s /persistent/home/.bash_history ~/)' >> /home/sandbox/.bashrc \
    && echo 'test -L ~/.zsh_history || (touch /persistent/home/.zsh_history; ln -s /persistent/home/.zsh_history ~/)' >> /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.gitconfig || (touch /persistent/home/.gitconfig; ln -s /persistent/home/.gitconfig ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.local || (mkdir -p /persistent/home/.local/share; ln -s /persistent/home/.local ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.claude || (mkdir -p /persistent/home/.claude; ln -s /persistent/home/.claude ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.claude.json || (touch /persistent/home/.claude.json; ln -s /persistent/home/.claude.json ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.gemini || (mkdir -p /persistent/home/.gemini; ln -s /persistent/home/.gemini ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local \
    && echo 'test -L ~/.codex || (mkdir -p /persistent/home/.codex; ln -s /persistent/home/.codex ~/)' | tee -a /home/sandbox/.bashrc /home/sandbox/.zshrc.local

ENV EDITOR="busybox vi"
ENV MISE_DATA_DIR=/persistent/mise-data
EOF
}

log() {
  echo "[$(date "+%Y-%m-%d %H:%M:%S%z")][$(hostname)] $*"
}

main() {
  local dockerfile=""
  local allow_write="no"
  local allow_net="no"
  local allow_net_destinations=()
  local volume_dirs=()
  local readonly_mounts=()
  local writable_mounts=()
  local publish_ports=()
  local env_file=""
  local allocate_tty="no"
  local no_cache="no"
  local platform=""

  VERBOSE="no"
  DRY_RUN="no"
  
  while test "$#" -gt 0; do
    case "$1" in
      --help        ) help; return 0 ;;
      --dockerfile  ) dockerfile="$2"; shift 2 ;;
      --platform    ) platform="$2"; shift 2 ;;
      --allow-write ) allow_write="yes"; shift ;;
      --allow-net   )
        allow_net="yes"
        if test -n "$2" && ! grep -q "^--" <<< "$2"; then
          local new_allow_net_destinations
          IFS=',' read -r -a new_allow_net_destinations <<< "$2"
          allow_net_destinations+=("${new_allow_net_destinations[@]}")
          shift 2
        else
          shift 1
        fi
        ;;
      --volume  )
        local new_volume_dirs
        IFS=',' read -r -a new_volume_dirs <<< "$2"
        volume_dirs+=("${new_volume_dirs[@]}")
        shift 2
        ;;
      --mount-readonly)
        local new_readonly_mounts
        IFS=',' read -r -a new_readonly_mounts <<< "$2"
        readonly_mounts+=("${new_readonly_mounts[@]}")
        shift 2
        ;;
      --mount-writable)
        local new_writable_mounts
        IFS=',' read -r -a new_writable_mounts <<< "$2"
        writable_mounts+=("${new_writable_mounts[@]}")
        shift 2
        ;;
      --publish     )
        local new_publish_ports
        IFS=',' read -r -a new_publish_ports <<< "$2"
        publish_ports+=("${new_publish_ports[@]}")
        shift 2
        ;;
      --env-file    )
        local env_file="$2"
        shift 2
        ;;
      --tty         ) allocate_tty="yes"; shift ;;
      --no-cache    ) no_cache="yes"; shift ;;
      --verbose     ) VERBOSE="yes"; shift ;;
      --dry-run     ) DRY_RUN="yes"; shift ;;
      --            ) shift; continue ;;
      --*           ) echo "Error: unknown option: $1" >&2; return 1 ;;
      *             ) break ;;
    esac
  done
  
  if test "$#" -eq 0; then
    help >&2
    return 1
  fi

  # save stdout, stderr
  exec 3>&1
  exec 4>&2

  run() {
    if test "$DRY_RUN" = "no"; then
      "$@"
    else
      echo "DRY_RUN: $*" >&3
    fi
  }
 
  if test "$VERBOSE" = "no"; then
    # discard stderr
    exec 2> /dev/null
  fi

  # stdout to stderr
  exec 1>&2

  log "Copy script to mountable path: $SCRIPT_PATH -> $MOUNTABLE_SCRIPT_PATH"
  run mkdir -p "$(dirname "$MOUNTABLE_SCRIPT_PATH")"
  run cp -f "$SCRIPT_PATH" "$MOUNTABLE_SCRIPT_PATH"
  chmod +x "$MOUNTABLE_SCRIPT_PATH"

  local host_user_id
  local host_group_id
  host_user_id=$(id -u)
  host_group_id=$(id -g)
  
  # set options
  local host_project_root
  local container_project_root
  local container_workdir
  host_project_root="$(git rev-parse --show-toplevel || pwd)"
  container_project_root="$host_project_root"
  container_workdir=$(pwd)

  local project_id
  local image_name
  local image_tag
  if which shasum &> /dev/null; then
    project_id="$(shasum -a 256 <<< "$(pwd)" | head -c 8)"
  elif which sha256sum &> /dev/null; then
    project_id="$(sha256sum <<< "$(pwd)" | head -c 8)"
  else
    echo "Error: Neither shasum nor sha256sum found. Please install one of them." >&2
    return 1
  fi
  image_name="${SCRIPT_NAME}--$(basename "$(pwd)")-$project_id"
  image_tag="latest"

  CONTAINER_NAME="${image_name}--$(env LC_CTYPE=C tr -dc '[:alnum:]' < /dev/urandom 2> /dev/null | head -c 10 || true)"
  NETWORK_NAME="${CONTAINER_NAME}"

  if test -z "$dockerfile"; then
    log "Dockerfile not specified, using preset configuration."
    "$SCRIPT_PATH" print_preset_dockerfile

    local platform_with_default="default"
    if test -n "$platform"; then
      platform_with_default="$platform"
    fi

    volume_dirs+=(
      # global persistent volume
      "${SCRIPT_NAME}--global--${platform_with_default}--mise-data:/persistent/mise-data"
      # project local persistent volume
      "${image_name}--home:/persistent/home"
    )

    if test "$allow_net" = "yes"; then
      allow_net_destinations+=(
        # mise
        "mise-versions.jdx.dev"

        # Claude Code
        "api.anthropic.com"
        "sentry.io"
        "statsig.anthropic.com"
        "statsig.com"

        # Gemini CLI
        "generativelanguage.googleapis.com"
        "oauth2.googleapis.com"
        "cloudcode-pa.googleapis.com"
        "play.googleapis.com"

        # Codex CLI
        "api.openai.com"
      )
    fi
  fi

  # docker options
  local docker_build_opts=(--tag "$image_name:$image_tag")
  local docker_run_opts=(
    --detach
    --name "$CONTAINER_NAME"
    --entrypoint ""
    --user 0:0
    --mount "type=bind,source=${MOUNTABLE_SCRIPT_PATH},target=${CONTAINER_SCRIPT_PATH},readonly"
  )
  local docker_exec_opts=(
    --interactive
    --workdir "$container_workdir"
    --user "$host_user_id:$host_group_id"
  )

  local docker_build_context=""
  if test -n "$dockerfile"; then
    docker_build_opts+=(--file "$dockerfile")
    docker_build_context=$(dirname "$dockerfile")
  fi

  if test "$no_cache" = "yes"; then
    docker_build_opts+=(--no-cache)
  fi

  if test -n "$platform"; then
    docker_build_opts+=(--platform "$platform")
    docker_run_opts+=(--platform "$platform")
  fi
  
  if test -n "$env_file"; then
    docker_run_opts+=(--env-file "$env_file")
  fi
  
  if test "$allow_write" = "yes"; then
    docker_run_opts+=(--mount "type=bind,source=${host_project_root},target=${container_project_root},consistency=delegated")
  else
    docker_run_opts+=(--mount "type=bind,source=${host_project_root},target=${container_project_root},readonly,consistency=delegated")
  fi
  
  if test "$allow_net" = "yes"; then
    docker_run_opts+=(
      --cap-add NET_ADMIN
      --cap-add NET_RAW
      --net "$NETWORK_NAME"
      --add-host host.docker.internal:host-gateway
    )
  else
    docker_run_opts+=(--net none)
  fi
  
  # volume options
  local volume_mount_paths=()
  if test "${#volume_dirs[@]}" -gt 0; then
    local volume_name
    local mount_path

    for dir in "${volume_dirs[@]}"; do
      if grep -qE ':' <<< "$dir"; then
        IFS=':' read -r volume_name mount_path <<< "$dir"
      else
        volume_name="${image_name}--$(echo "$dir" | sed 's,/,-,g; s,\.,-dot-,g')"
        mount_path="$dir"
        if ! grep -qE "^/" <<< "$mount_path"; then
          if ! test -e "$dir"; then
            mkdir -p "$dir"
          fi
          mount_path=$(readlink -f "$dir")
        fi
      fi

      docker_run_opts+=(--mount "type=volume,source=${volume_name},target=${mount_path},consistency=delegated")
      volume_mount_paths+=("$mount_path")
    done
  fi

  # mount options
  if test "${#readonly_mounts[@]}" -gt 0; then
    for mount in "${readonly_mounts[@]}"; do
      local host_path
      local container_path
      IFS=':' read -r host_path container_path <<< "$mount"
      local host_abs_path="$host_path"
      if ! grep -qE '^/' <<< "$host_abs_path"; then
        # shellcheck disable=SC2001
        host_abs_path=$(readlink -f "$(sed "s,~/,$HOME/," <<< "$host_abs_path")")
      fi
      docker_run_opts+=(--mount "type=bind,source=${host_abs_path},target=${container_path},readonly,consistency=delegated")
    done
  fi
  
  if test "${#writable_mounts[@]}" -gt 0; then
    for mount in "${writable_mounts[@]}"; do
      local host_path
      local container_path
      IFS=':' read -r host_path container_path <<< "$mount"
      local host_abs_path="$host_path"
      if ! grep -qE '^/' <<< "$host_abs_path"; then
        # shellcheck disable=SC2001
        host_abs_path=$(readlink -f "$(sed "s,~/,$HOME/," <<< "$host_abs_path")")
      fi
      docker_run_opts+=(--mount "type=bind,source=${host_abs_path},target=${container_path},consistency=delegated")
    done
  fi

  # publish options
  if test "${#publish_ports[@]}" -gt 0; then
    for port in "${publish_ports[@]}"; do
      if grep -qE '.+:.+:.+' <<< "$port"; then
        # host_address:host_port:container_port
        IFS=':' read -r host_address host_port container_port <<< "$port"
        docker_run_opts+=(--publish "${host_address}:${host_port}:${container_port}")
      elif grep -qE '.+:.+' <<< "$port"; then
        # host_port:container_port
        IFS=':' read -r host_port container_port <<< "$port"
        docker_run_opts+=(--publish "127.0.0.1:${host_port}:${container_port}")
      else
        echo "Error: Invalid port format: $port" >&2
        return 1
      fi
    done
  fi
  
  if test "$allocate_tty" = "yes"; then
    docker_exec_opts+=(--tty)
  fi

  on_exit() {
    local exit_status="$?"
  
    if test "$VERBOSE" = "no"; then
      exec 2> /dev/null
    fi
    exec 1>&2
  
    log "Stopping container."
    run docker stop -t 0 "$CONTAINER_NAME" || true
  
    log "Removing container."
    run docker rm -f "$CONTAINER_NAME" || true
  
    if docker network inspect "$NETWORK_NAME" &> /dev/null; then
      log "Removing network."
      run docker network rm "$NETWORK_NAME"
    fi

    exec 3>&-
    exec 4>&-
  
    return "$exit_status"
  }
  
  trap 'on_exit' EXIT

  # shellcheck disable=SC2001
  log "$(cat << EOF
Sandbox Configurations:
  docker_build_opts=
    $(echo "${docker_build_opts[*]}" | sed 's, ,\n    ,g')
  docker_build_context=$docker_build_context
  docker_run_opts=
    $(echo "${docker_run_opts[*]}" | sed 's, ,\n    ,g')
  docker_exec_opts=
    $(echo "${docker_exec_opts[*]}" | sed 's, ,\n    ,g')
  command=$@
EOF
  )"

  log "Building docker image."
  if test -n "$dockerfile"; then
    run docker build "${docker_build_opts[@]}" "$docker_build_context"
  else
    run docker build "${docker_build_opts[@]}" - \
      < <("$SCRIPT_PATH" print_preset_dockerfile)
  fi

  if test "$allow_net" = "yes"; then
    log "Creating network."
    run docker network create "$NETWORK_NAME" --driver bridge \
      -o com.docker.network.bridge.enable_ip_masquerade=true
  fi

  log "Inspect container user and group id."
  local container_default_user_group
  local container_default_user_id
  local container_default_group_id
  if test "$DRY_RUN" = "no"; then
    container_default_user_group=$(docker run --rm "${image_name}:${image_tag}" bash -c 'echo $(id -u):$(id -g)')
  else
    container_default_user_group="0:0"
  fi
  container_default_user_id=$(cut -d: -f1 <<< "$container_default_user_group")
  container_default_group_id=$(cut -d: -f2 <<< "$container_default_user_group")
  log "Container default user and group id: $container_default_user_group"
  
  log "Starting container."
  run docker run "${docker_run_opts[@]}" "${image_name}:${image_tag}" \
    "$CONTAINER_SCRIPT_PATH" start_container_dnsmasq

  if test "${#volume_mount_paths[@]}" -gt 0; then
    log "Setting up volume ownership to match host user ($host_user_id:$host_group_id)."
    run docker exec --user 0:0 "$CONTAINER_NAME" "$CONTAINER_SCRIPT_PATH" setup_container_volume_owner \
      "$host_user_id" "$host_group_id" "${volume_mount_paths[@]}"
  fi

  if test "$allow_net" = "yes"; then
    log "Setting up firewall."
    run docker exec --user 0:0 "$CONTAINER_NAME" \
      "$CONTAINER_SCRIPT_PATH" setup_container_firewall "${allow_net_destinations[@]}"
  fi
  
  log "Setting up container user to match host user ($host_user_id:$host_group_id) for file access."
  run docker exec --user 0:0 "$CONTAINER_NAME" "$CONTAINER_SCRIPT_PATH" setup_container_user \
     "$container_default_user_id" "$container_default_group_id" \
     "$host_user_id" "$host_group_id"
  
  # restore stdout, stderr
  exec 1>&3
  exec 2>&4
  
  run docker exec "${docker_exec_opts[@]}" "$CONTAINER_NAME" "$@"
}

start_container_dnsmasq() {
  local servers=()
  IFS=$'\n' read -r -a servers < <(grep nameserver /etc/resolv.conf | awk '{print $2}')

  mkdir -p /sandbox/etc
  cat > /sandbox/etc/dnsmasq.conf << 'EOF'
log-queries
listen-address=127.0.0.1
EOF
  for server in "${servers[@]}"; do
    echo "server=$server" >> /sandbox/etc/dnsmasq.conf
  done
  echo "nameserver 127.0.0.1" > /etc/resolv.conf

  dnsmasq -k -C /sandbox/etc/dnsmasq.conf --log-facility /dev/stdout
}

setup_container_volume_owner() {
  local host_user_id=$1
  local host_group_id=$2
  shift 2

  for mount_path in "$@"; do
    chown "$host_user_id:$host_group_id" "$mount_path"
  done
}

# Future improvements:
# - Use ipset
setup_container_firewall() {
  local destinations=("$@")
  local addresses=()

  local address_pattern='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(/[0-9]{1,2})?$'
  
  for destination in "${destinations[@]}"; do
    local host="$destination"
    local port=''
    if grep -q ':' <<< "$destination"; then
      host=$(cut -d: -f1 <<< "$destination")
      port=$(cut -d: -f2 <<< "$destination")
    fi

    # address
    if grep -qE "$address_pattern" <<< "$host"; then
      echo "Allow outgoing connections to $destination"
      if test -n "$port"; then
        addresses+=("$host:$port")
      else
        addresses+=("$host")
      fi
      continue
    fi

    # domain
    local domain_address_count=0
    for address in $(getent hosts "$host" | awk '{print $1}'; dig +short A "$host"); do
      if ! grep -qE "$address_pattern" <<< "$address"; then
        log "Warn: Ignore invalid address $address of $host"
        continue
      fi

      if test -n "$port"; then
        log "Allow outgoing connections to $destination $address:$port"
        addresses+=("$address:$port")
      else
        log "Allow outgoing connections to $destination $address"
        addresses+=("$address")
      fi

      domain_address_count=$((domain_address_count + 1))
    done

    if test "$domain_address_count" = 0; then
      echo "Error: Failed to resolve any address for $host" >&2
      return 1
    fi
  done
  
  local docker_host_address
  docker_host_address=$(busybox ip route | grep default | cut -d" " -f3)
  if test -z "$docker_host_address"; then
    echo "Error: Failed to determine docker host address" >&2
    return 1
  fi

  # reset
  iptables -F
  iptables -X
  # iptables -t nat -F
  # iptables -t nat -X
  iptables -t mangle -F
  iptables -t mangle -X
  
  # allow dns
  iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
  iptables -A INPUT -p udp --sport 53 -j ACCEPT
  
  # allow localhost
  iptables -A INPUT -i lo -j ACCEPT
  iptables -A OUTPUT -o lo -j ACCEPT
  
  # set default policies
  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT DROP
  
  # allow access from docker host
  iptables -A INPUT -s "$docker_host_address" -j ACCEPT
  # Do not allow access to docker host by default
  # iptables -A OUTPUT -d "$docker_host_address" -j ACCEPT
  
  # allow established connections
  iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  
  # allow given addresses
  for address in "${addresses[@]}"; do
    if grep -q ':' <<< "$address"; then
      local address_part
      local port
      IFS=':' read -r address_part port <<< "$address"
      iptables -A OUTPUT -d "$address_part" -p tcp --dport "$port" -j ACCEPT
    else
      # allow only HTTPS (443) connections
      iptables -A OUTPUT -d "$address" -p tcp --dport 443 -j ACCEPT
    fi
  done
}

setup_container_user() {
  local container_default_user_id="$1"
  local container_default_group_id="$2"
  local host_user_id="$3"
  local host_group_id="$4"

  local user
  local group
  user=$(getent passwd "$container_default_user_id" | cut -d: -f1 2> /dev/null || echo "")
  group=$(getent group "$container_default_group_id" | cut -d: -f1 2> /dev/null || echo "")

  if test "$container_default_user_id" -eq 0; then
    log "Container default user is root, creating sandbox user/group"
    
    if ! getent group sandbox &> /dev/null; then
      log "Creating group sandbox"
      groupadd sandbox
    fi
    
    if ! getent passwd sandbox &> /dev/null; then
      log "Creating user sandbox"
      useradd -g sandbox -m sandbox
    fi
    
    user="sandbox"
    group="sandbox"
  fi

  log "Updating group '$group' ID to $host_group_id"
  local conflicting_group
  conflicting_group=$(getent group "$host_group_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_group" && test "$conflicting_group" != "$group"; then
    log "Resolving group ID conflict: moving group '$conflicting_group'"
    local temp_gid
    for gid in $(seq 1000 65533); do
      if ! getent group "$gid" &> /dev/null; then
        temp_gid=$gid
        break
      fi
    done
    
    if test -z "$temp_gid"; then
      echo "Error: No available GID in user range" >&2
      return 1
    fi
    
    groupmod -g "$temp_gid" "$conflicting_group"
  fi

  groupmod -g "$host_group_id" "$group"

  log "Updating user '$user' ID to $host_user_id:$host_group_id"
  local conflicting_user
  conflicting_user=$(getent passwd "$host_user_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_user" && test "$conflicting_user" != "$user"; then
    log "Resolving user ID conflict: moving user '$conflicting_user'"
    local temp_uid
    for uid in $(seq 1000 65533); do
      if ! getent passwd "$uid" &> /dev/null; then
        temp_uid=$uid
        break
      fi
    done
    
    if test -z "$temp_uid"; then
      echo "Error: No available UID in user range" >&2
      return 1
    fi
    
    usermod -u "$temp_uid" "$conflicting_user"
  fi

  usermod -u "$host_user_id" -g "$host_group_id" "$user"

  # Adjust home directory permissions to match new UID/GID
  local home_dir
  home_dir=$(getent passwd "$user" | cut -d: -f6)
  if test -n "$home_dir" && test -d "$home_dir"; then
    log "Updating home directory ownership: $home_dir"
    chown "$host_user_id:$host_group_id" "$home_dir" || true
  fi

  log "User setup completed: $user ($host_user_id:$host_group_id)"
}

if test "$#" -gt 0; then
  case "$1" in
    start_container_dnsmasq | setup_container_volume_owner | setup_container_firewall | setup_container_user | print_preset_dockerfile )
      "$@"
      ;;
    * )
      main "$@"
  esac
else
  main
fi
