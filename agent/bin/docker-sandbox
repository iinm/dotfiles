#!/usr/bin/env bash

set -eu -o pipefail

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"

help() {
  cat << HELP
Usage: $SCRIPT_NAME --dockerfile FILE
           [--allow-write] [--allow-net|--allow-net-host-only]
           [--use-volume DIR] [--tty] [--verbose]
           COMMAND

Execute a command within a container defined by a Dockerfile.

  --dockerfile FILE      (Required) Path to the Dockerfile.
  --allow-write          Enable write access to the project root directory inside the container.
                         (By default, the project root is mounted read-only.)
  --allow-net            Allow full network access for the container.
  --allow-net-host-only  Allow network access only to the host machine (via a dedicated bridge network).
  --use-volume DIR       Mount a named volume for the specified host directory.
                         The volume will be mounted at the absolute path of DIR inside the container.
  --tty                  Allocate a pseudo-TTY for the container.
  --verbose              Output verbose logs to stderr.

Examples:
  $SCRIPT_NAME --dockerfile ./Dockerfile.sandbox --verbose --tty bash
  $SCRIPT_NAME --dockerfile ./Dockerfile.sandbox --allow-write --allow-net --use-volume node_module npm install
  $SCRIPT_NAME --dockerfile ./Dockerfile.sandbox --allow-net-host-only wget -O - host.docker.internal:8000 
HELP
}

verbose="no"
dockerfile=""
allow_write="no"
allow_net="no"
volume_dirs=()
allocate_tty="no"

while test "$#" -gt 0; do
  case "$1" in
    --help                ) help; exit 0 ;;
    --dockerfile          ) dockerfile="$2"; shift 2 ;;
    --verbose             ) verbose="yes"; shift ;;
    --allow-write         ) allow_write="yes"; shift ;;
    --allow-net           ) allow_net="yes"; shift ;;
    --allow-net-host-only ) allow_net="host_only"; shift ;;
    --tty                 ) allocate_tty="yes"; shift ;;
    --use-volume          ) volume_dirs+=("$2"); shift 2 ;;
    --*                   ) echo "Error: unknown option: $1" >&2; exit 1 ;;
    *                     ) break ;;
  esac
done

# validate arguments
if test -z "$dockerfile"; then
  echo "Error: --dockerfile is required" >&2
  help >&2
  exit 1
fi

if test "$#" -eq 0; then
  echo "Error: COMMAND is required" >&2
  help >&2
  exit 1
fi

# save stdout, stderr
exec {stdout}>&1
exec {stderr}>&2

if test "$verbose" = "no"; then
  # discard stderr
  exec 2> /dev/null
fi
# stdout to stderr
exec 1>&2

# set options
project_root="$(git rev-parse --show-toplevel || pwd)"
image_name="${SCRIPT_NAME}--$(basename "$(pwd)")"
image_tag="latest"
container_name="${image_name}--$(env LC_CTYPE=C tr -dc '[:alnum:]' < /dev/urandom 2> /dev/null | head -c 10 || true)"
host_only_network_name="${image_name}--host-only"

docker_run_opts=(
  --name "$container_name"
  --interactive
  --user 0:0
  --add-host host.docker.internal:host-gateway
  --cap-add NET_ADMIN
)

docker_exec_opts=(
  --interactive
  --workdir "$(pwd)"
)

if test "$allow_write" = "yes"; then
  docker_run_opts+=(--volume "${project_root}:${project_root}")
else
  docker_run_opts+=(--volume "${project_root}:${project_root}:ro")
fi

if test "$allow_net" = "yes"; then
  :
elif test "$allow_net" = "host_only"; then
  docker_run_opts+=(--net "$host_only_network_name")
else
  docker_run_opts+=(--net none)
fi

for dir in "${volume_dirs[@]}"; do
  volume_name="$(basename "$(pwd)")--${dir//\//-}"
  mount_path="$(readlink -f "${dir}")"
  docker_run_opts+=(--volume "${volume_name}:${mount_path}")
  if test "$(uname)" = "Linux"; then
    docker run --rm -v "${volume_name}:/mnt" busybox:latest chown "$(id -u):$(id -g)" /mnt
  fi
done

if test "$allocate_tty" = "yes"; then
  docker_exec_opts+=(--tty)
fi

if test "$(uname)" = "Linux"; then
  docker_exec_opts+=(--user "$(id -u):$(id -g)")
fi

log() {
  now="$(date "+%Y-%m-%d %H:%M:%S")"
  echo -e "$now" "$@"
}

on_exit() {
  local exit_status="$?"

  if test "$verbose" = "no"; then
    exec 2> /dev/null
  fi
  exec 1>&2

  log "Stop container"
  docker stop -t 0 "$container_name" || true

  log "Remove container"
  docker rm -f "$container_name" || true

  if docker network inspect "$host_only_network_name" &> /dev/null; then
    log "Remove network"
    docker network rm "$host_only_network_name"
  fi

  return "$exit_status"
}

trap 'on_exit' EXIT

log "$(cat << EOF
Sandbox Configurations:
  dockerfile=${dockerfile}
  image_name=${image_name}
  image_tag=${image_tag}
  docker_run_opts=${docker_run_opts[@]}
  docker_exec_opts=${docker_exec_opts[@]}
  command=$@
EOF
)"

log "Build docker image"
# shellcheck disable=SC2068
if ! docker build --tag "${image_name}:${image_tag}" - < "$dockerfile"; then
  log "Error: failed to build image"
  exit 1
fi

if test "$allow_net" = "host_only"; then
  log "Create host-only network"
  docker network create "$host_only_network_name" --driver bridge \
    -o com.docker.network.bridge.enable_ip_masquerade=false
fi

log "Create container"
# shellcheck disable=SC2068
docker run ${docker_run_opts[@]} "${image_name}:${image_tag}" sh < /dev/null

log "Start container"
docker start "$container_name"

# TODO: setup firewall
# ref. https://github.com/anthropics/claude-code/blob/main/.devcontainer/init-firewall.sh

# restore stdout, stderr
exec 2>&${stderr} {stderr}>&-
exec 1>&${stdout} {stdout}>&-

# shellcheck disable=SC2068
docker exec ${docker_exec_opts[@]} "$container_name" $@
