#!/usr/bin/env bash

set -eu -o pipefail

SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
CONTAINER_SCRIPT_PATH="/sandbox/bin/$SCRIPT_NAME"

help() {
  cat << HELP
Usage: $SCRIPT_NAME --dockerfile FILE
           [--platform PLATFORM]
           [--allow-write] [--allow-net [DESTINATIONS]]
           [--use-volume DIRECTORIES]
           [--mount-writable HOST_DIR:CONTAINER_DIR] [--mount-readonly HOST_DIR:CONTAINER_DIR]
           [--publish [[HOST_ADDRESS:]HOST_PORT:]CONTAINER_PORT]
           [--env-file FILE]
           [--tty]
           [--no-cache]
           [--verbose] [--dry-run]
           COMMAND

Execute a command within a container defined by a Dockerfile.

  --dockerfile FILE         (Required) Path to the Dockerfile.
  --platform                Specify the platform for both image building and container execution. For example: linux/arm64 or linux/amd64.
  --allow-write             Enable write access to the project root directory inside the container.
                            By default, the project root (git root or current directory) is mounted read-only.
  --allow-net DESTINATIONS  Allow connections to the specified domain or IP address.
                            Multiple destinations can be specified, separated by commas.
                             When no port is specified, allow only HTTPS (443) connections.
                            e.g. host.docker.internal:8000,registry.npmjs.org
  --use-volume DIRECTORIES  Mount a named volume for the specified host directory.
                            Multiple directories can be specified, separated by commas.
                            The volume will be mounted at the absolute path of DIR inside the container.
  --mount-readonly HOST_DIR:CONTAINER_DIR
                            Mount a host directory to a container directory with read-only access.
  --mount-writable HOST_DIR:CONTAINER_DIR
                            Mount a host directory to a container directory with write access.
  --publish [[HOST_ADDRESS:]HOST_PORT:]CONTAINER_PORT
                            Publish a container's port(s) to the host. If the host address is not specified,
                            the port will be bound to 127.0.0.1 by default.
  --env-file FILE           Path to a .env file to load environment variables from.
  --tty                     Allocate a pseudo-TTY for the container.
  --no-cache                Do not use cache when building the image.
  --verbose                 Output verbose logs to stderr.
  --dry-run                 Do not execute the command, just print the command to stdout.

Examples:
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --tty bash
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --allow-write --allow-net registry.npmjs.org --use-volume node_modules npm install
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --allow-net host.docker.internal:3306 npm run test
HELP
}

main() {
  local dockerfile=""
  local allow_write="no"
  local allow_net="no"
  local allow_net_destinations=()
  local volume_dirs=()
  local readonly_mounts=()
  local writable_mounts=()
  local publish_ports=()
  local env_file=""
  local allocate_tty="no"
  local no_cache="no"
  local platform=""

  VERBOSE="no"
  DRY_RUN="no"
  
  while test "$#" -gt 0; do
    case "$1" in
      --help        ) help; return 0 ;;
      --dockerfile  ) dockerfile="$2"; shift 2 ;;
      --platform    ) platform="$2"; shift 2 ;;
      --allow-write ) allow_write="yes"; shift ;;
      --allow-net   )
        allow_net="yes"
        if test -n "$2" && ! grep -q "^--" <<< "$2"; then
          IFS=',' read -r -a allow_net_destinations <<< "$2"
          shift 2
        else
          shift 1
        fi
        ;;
      --use-volume  )
        IFS=',' read -r -a volume_dirs <<< "$2"
        shift 2
        ;;
      --mount-readonly)
        IFS=',' read -r -a readonly_mounts <<< "$2"
        shift 2
        ;;
      --mount-writable)
        IFS=',' read -r -a writable_mounts <<< "$2"
        shift 2
        ;;
      --publish     )
        IFS=',' read -r -a publish_ports <<< "$2"
        shift 2
        ;;
      --env-file    )
        local env_file="$2"
        shift 2
        ;;
      --tty         ) allocate_tty="yes"; shift ;;
      --no-cache    ) no_cache="yes"; shift ;;
      --verbose     ) VERBOSE="yes"; shift ;;
      --dry-run     ) DRY_RUN="yes"; shift ;;
      --            ) shift; continue ;;
      --*           ) echo "Error: unknown option: $1" >&2; return 1 ;;
      *             ) break ;;
    esac
  done
  
  if test "$#" -eq 0; then
    echo "Error: COMMAND is required" >&2
    help >&2
    return 1
  fi
  
  log() {
    echo "[$(date "+%Y-%m-%d %H:%M:%S%z")] $*"
  }

  # save stdout, stderr
  exec 3>&1
  exec 4>&2
 
  run() {
    if test "$DRY_RUN" = "yes"; then
      echo "DRY_RUN: $*" >&3
      return 0
    fi
    "$@"
  }
 
  if test "$VERBOSE" = "no"; then
    # discard stderr
    exec 2> /dev/null
  fi

  # stdout to stderr
  exec 1>&2

  local host_user_id
  local host_group_id
  host_user_id=$(id -u)
  host_group_id=$(id -g)
  
  # set options
  local host_project_root
  local container_project_root
  local container_workdir
  host_project_root="$(git rev-parse --show-toplevel || pwd)"
  container_project_root="$host_project_root"
  container_workdir="$host_project_root"

  local image_name
  local image_tag
  image_name="${SCRIPT_NAME}--$(basename "$(pwd)")"
  image_tag="latest"

  CONTAINER_NAME="${image_name}--$(env LC_CTYPE=C tr -dc '[:alnum:]' < /dev/urandom 2> /dev/null | head -c 10 || true)"
  NETWORK_NAME="${CONTAINER_NAME}"

  local docker_platform_opts=()
  if test -n "$platform"; then
    docker_platform_opts+=(--platform "$platform")
  fi
 
  local docker_build_opts=(--tag "$image_name:$image_tag")
  local docker_build_context=""
  if test -n "$dockerfile"; then
    docker_build_opts+=(--file "$dockerfile")
    docker_build_context=$(dirname "$dockerfile")
  else
    # No Dockerfile -> Use preset Dockerfile
    local host_persistent_dir=".$SCRIPT_NAME/persistent"

    # Persist shell history, mise data
    local host_persistent_home_dir="$host_persistent_dir/home/sandbox"
    mkdir -p "$host_persistent_home_dir"
    touch "$host_persistent_home_dir/.bash_history"
    touch "$host_persistent_home_dir/.zsh_history"
    touch "$host_persistent_home_dir/.zsh_history.new"
    mkdir -p "$host_persistent_home_dir/.local"
    writable_mounts+=(
      "$host_persistent_home_dir/.bash_history:/home/sandbox/.bash_history"
      "$host_persistent_home_dir/.zsh_history:/home/sandbox/.zsh_history"
      "$host_persistent_home_dir/.zsh_history.new:/home/sandbox/.zsh_history.new"
      "$host_persistent_home_dir/.local:/home/sandbox/.local"
    )

    # allow access to host LLM provider configurations
    mkdir -p "$HOME/.claude"
    touch "$HOME/.claude.json"
    mkdir -p "$HOME/.gemini"
    writable_mounts+=(
      "$HOME/.claude:/home/sandbox/.claude"
      "$HOME/.claude.json:/home/sandbox/.claude.json"
      "$HOME/.gemini:/home/sandbox/.gemini"
    )

    # allow access to LLM providers
    allow_net="yes"
    allow_net_destinations+=(
      "api.anthropic.com"
      "statsig.anthropic.com"
      # TODO
      "www.googleapis.com"
      "generativelanguage.googleapis.com"
    )

    allocate_tty="yes"
  fi

  if test "$no_cache" = "yes"; then
    docker_build_opts+=(--no-cache)
  fi

  local docker_run_opts=(
    --name "$CONTAINER_NAME"
    --entrypoint ""
    --user "$host_user_id:$host_group_id"
    --mount "type=bind,source=${SCRIPT_PATH},target=${CONTAINER_SCRIPT_PATH},readonly"
  )
  
  local docker_exec_opts=(
    --interactive
    --workdir "$container_workdir"
    --user "$host_user_id:$host_group_id"
  )

  if test -n "$env_file"; then
    docker_run_opts+=(--env-file "$env_file")
  fi
  
  if test "$allow_write" = "yes"; then
    docker_run_opts+=(--volume "${host_project_root}:${container_project_root}")
  else
    docker_run_opts+=(--volume "${host_project_root}:${container_project_root}:ro")
  fi
  
  if test "$allow_net" = "yes"; then
    docker_run_opts+=(
      --cap-add NET_ADMIN
      --cap-add NET_RAW
      --net "$NETWORK_NAME"
      --add-host host.docker.internal:host-gateway
    )
  else
    docker_run_opts+=(--net none)
  fi
  
  # volume options
  for dir in "${volume_dirs[@]}"; do
    volume_name="${image_name}--$(echo "$dir" | sed 's,/,-,g; s,\.,-dot-,g')"
    mount_path="$dir"
    if ! grep -qE "^/" <<< "$mount_path"; then
      if ! test -e "$dir"; then
        mkdir -p "$dir"
      fi
      mount_path="$(readlink -f "${dir}" | sed "s,^${host_project_root},${container_project_root},")"
    fi
    docker_run_opts+=(--volume "${volume_name}:${mount_path}")
    log "Setting up volume ownership for $dir ($host_user_id:$host_group_id)"
    run docker run --rm -v "${volume_name}:/mnt" busybox:latest chown "$host_user_id:$host_group_id" /mnt
  done

  # mount options
  for mount in "${readonly_mounts[@]}"; do
    local host_dir
    local container_dir
    IFS=':' read -r host_dir container_dir <<< "$mount"
    docker_run_opts+=(--mount "type=bind,source=${host_dir},target=${container_dir},readonly")
  done
  
  for mount in "${writable_mounts[@]}"; do
    local host_dir
    local container_dir
    IFS=':' read -r host_dir container_dir <<< "$mount"
    docker_run_opts+=(--mount "type=bind,source=${host_dir},target=${container_dir}")
  done

  # publish options
  for port in "${publish_ports[@]}"; do
    if grep -qE '.+:.+:.+' <<< "$port"; then
      # host_address:host_port:container_port
      IFS=':' read -r host_address host_port container_port <<< "$port"
      docker_run_opts+=(--publish "${host_address}:${host_port}:${container_port}")
    elif grep -qE '.+:.+' <<< "$port"; then
      # host_port:container_port
      IFS=':' read -r host_port container_port <<< "$port"
      docker_run_opts+=(--publish "127.0.0.1:${host_port}:${container_port}")
    else
      # # container_port
      docker_run_opts+=(--publish "127.0.0.1::${port}")
    fi
  done
  
  if test "$allocate_tty" = "yes"; then
    docker_exec_opts+=(--tty)
  fi

  on_exit() {
    local exit_status="$?"
  
    if test "$VERBOSE" = "no"; then
      exec 2> /dev/null
    fi
    exec 1>&2
  
    log "Stopping container"
    run docker stop -t 0 "$CONTAINER_NAME" || true
  
    log "Removing container"
    run docker rm -f "$CONTAINER_NAME" || true
  
    if docker network inspect "$NETWORK_NAME" &> /dev/null; then
      log "Removing network"
      run docker network rm "$NETWORK_NAME"
    fi

    exec 3>&-
    exec 4>&-
  
    return "$exit_status"
  }
  
  trap 'on_exit' EXIT

  log "$(cat << EOF
Sandbox Configurations:
  docker_platform_opts=(${docker_platform_opts[@]})
  docker_build_opts=(${docker_build_opts[@]})
  docker_build_context=$docker_build_context
  docker_run_opts=(${docker_run_opts[@]})
  docker_exec_opts=(${docker_exec_opts[@]})
  command=$@
EOF
  )"

  log "Building docker image"
  if test -n "$dockerfile"; then
    run docker build "${docker_platform_opts[@]}" "${docker_build_opts[@]}" "$docker_build_context"
  else
    run docker build "${docker_platform_opts[@]}" "${docker_build_opts[@]}" - \
      < <("$SCRIPT_PATH" print_preset_dockerfile)
  fi

  if test "$allow_net" = "yes"; then
    log "Creating network"
    run docker network create "$NETWORK_NAME" --driver bridge \
      -o com.docker.network.bridge.enable_ip_masquerade=true
  fi

  log "Inspect container user and group id"
  local container_default_user_group
  local container_default_user_id
  local container_default_group_id
  if test "$DRY_RUN" = "no"; then
    container_default_user_group=$(docker run --rm "${docker_platform_opts[@]}" "${image_name}:${image_tag}" bash -c 'echo $(id -u):$(id -g)')
  else
    container_default_user_group="0:0"
  fi
  container_default_user_id=$(cut -d: -f1 <<< "$container_default_user_group")
  container_default_group_id=$(cut -d: -f2 <<< "$container_default_user_group")
  echo "Container default user and group id: $container_default_user_group"
  
  log "Starting container"
  run docker run --detach "${docker_platform_opts[@]}" "${docker_run_opts[@]}" "${image_name}:${image_tag}" tail -f /dev/null

  if test "$allow_net" = "yes"; then
    log "Setting up firewall"
    run docker exec --user 0:0 "$CONTAINER_NAME" "$CONTAINER_SCRIPT_PATH" setup_container_firewall "${allow_net_destinations[@]}"
  fi
  
  log "Setting up container user to match host user ($host_user_id:$host_group_id) for file access"
  run docker exec --user 0:0 "$CONTAINER_NAME" "$CONTAINER_SCRIPT_PATH" setup_container_user \
     "$container_default_user_id" "$container_default_group_id" \
     "$host_user_id" "$host_group_id"
  
  # restore stdout, stderr
  exec 1>&3
  exec 2>&4
  
  run docker exec "${docker_exec_opts[@]}" "$CONTAINER_NAME" "$@"
}

setup_container_firewall() {
  local destinations=("$@")
  local addresses=()

  local address_pattern='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'
  
  for destination in "${destinations[@]}"; do
    local host="$destination"
    local port=''
    if grep -q ':' <<< "$destination"; then
      host=$(cut -d: -f1 <<< "$destination")
      port=$(cut -d: -f2 <<< "$destination")
    fi

    # address
    if grep -qE "$address_pattern" <<< "$host"; then
      echo "Allow outgoing connections to $destination"
      if test -n "$port"; then
        addresses+=("$host:$port")
      else
        addresses+=("$host")
      fi
      continue
    fi

    # domain
    local domain_address_count=0
    for address in $(getent hosts "$host" | awk '{print $1}'; dig +short A "$host"); do
      if ! grep -qE "$address_pattern" <<< "$address"; then
        echo "Warn: Ignore invalid address $address of $host" >&2
        continue
      fi

      if test -n "$port"; then
        echo "Allow outgoing connections to $destination $address:$port"
        addresses+=("$address:$port")
      else
        echo "Allow outgoing connections to $destination $address"
        addresses+=("$address")
      fi

      domain_address_count=$((domain_address_count + 1))
    done

    if test "$domain_address_count" = 0; then
      echo "Error: Failed to resolve any address for $host" >&2
      return 1
    fi
  done
  
  docker_host_address=$(ip route | grep default | cut -d" " -f3)
  if test -z "$docker_host_address"; then
    echo "Error: Failed to determine docker host address" >&2
    return 1
  fi
  
  # reset
  iptables -F
  iptables -X
  #iptables -t nat -F
  #iptables -t nat -X
  iptables -t mangle -F
  iptables -t mangle -X
  
  # allow dns
  iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
  iptables -A INPUT -p udp --sport 53 -j ACCEPT
  
  # allow localhost
  iptables -A INPUT -i lo -j ACCEPT
  iptables -A OUTPUT -o lo -j ACCEPT
  
  # set default policies
  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT DROP
  
  # allow docker host
  iptables -A INPUT -s "$docker_host_address" -j ACCEPT
  iptables -A OUTPUT -d "$docker_host_address" -j ACCEPT
  
  # allow established connections
  iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  
  # allow given addresses
  for address in "${addresses[@]}"; do
    if grep -q ':' <<< "$address"; then
      address=$(cut -d: -f1 <<< "$address")
      port=$(cut -d: -f2 <<< "$address")
      iptables -A OUTPUT -d "$address" -p tcp --dport "$port" -j ACCEPT
    else
      # allow only HTTPS (443) connections
      iptables -A OUTPUT -d "$address" -p tcp --dport 443 -j ACCEPT
    fi
  done
}

setup_container_user() {
  local container_default_user_id="$1"
  local container_default_group_id="$2"
  local host_user_id="$3"
  local host_group_id="$4"

  local user
  local group
  user=$(getent passwd "$container_default_user_id" | cut -d: -f1 2> /dev/null || echo "")
  group=$(getent group "$container_default_group_id" | cut -d: -f1 2> /dev/null || echo "")

  if test "$container_default_user_id" -eq 0; then
    echo "Container default user is root, creating sandbox user/group"
    
    if ! getent group sandbox &> /dev/null; then
      echo "Creating group sandbox"
      groupadd sandbox
    fi
    
    if ! getent passwd sandbox &> /dev/null; then
      echo "Creating user sandbox"
      useradd -g sandbox -m sandbox
    fi
    
    user="sandbox"
    group="sandbox"
  fi

  echo "Updating group '$group' ID to $host_group_id"
  local conflicting_group
  conflicting_group=$(getent group "$host_group_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_group" && test "$conflicting_group" != "$group"; then
    echo "Resolving group ID conflict: moving group '$conflicting_group'"
    local temp_gid
    for gid in $(seq 1000 65533); do
      if ! getent group "$gid" &> /dev/null; then
        temp_gid=$gid
        break
      fi
    done
    
    if test -z "$temp_gid"; then
      echo "Error: No available GID in user range" >&2
      return 1
    fi
    
    groupmod -g "$temp_gid" "$conflicting_group"
  fi

  groupmod -g "$host_group_id" "$group"

  echo "Updating user '$user' ID to $host_user_id:$host_group_id"
  local conflicting_user
  conflicting_user=$(getent passwd "$host_user_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_user" && test "$conflicting_user" != "$user"; then
    echo "Resolving user ID conflict: moving user '$conflicting_user'"
    local temp_uid
    for uid in $(seq 1000 65533); do
      if ! getent passwd "$uid" &> /dev/null; then
        temp_uid=$uid
        break
      fi
    done
    
    if test -z "$temp_uid"; then
      echo "Error: No available UID in user range" >&2
      return 1
    fi
    
    usermod -u "$temp_uid" "$conflicting_user"
  fi

  usermod -u "$host_user_id" -g "$host_group_id" "$user"

  # Adjust home directory permissions to match new UID/GID
  local home_dir
  home_dir=$(getent passwd "$user" | cut -d: -f6)
  if test -n "$home_dir" && test -d "$home_dir"; then
    echo "Updating home directory ownership: $home_dir"
    chown "$host_user_id:$host_group_id" "$home_dir" || true
  fi

  echo "User setup completed: $user ($host_user_id:$host_group_id)"
}

print_preset_dockerfile() {
  cat << 'EOF'
FROM debian:12

RUN apt update && apt install -y \
      bash zsh \
      iptables ipset iproute2 \
      dnsutils iputils-ping netcat-openbsd \
      gpg \
      curl \
      git \
      xz-utils

# https://grml.org/zsh/
RUN curl -fsSL https://grml.org/console/zshrc -o /etc/skel/.zshrc \
    && curl -fsSL https://grml.org/console/zshrc.local -o /etc/skel/.zshrc.local

# https://mise.jdx.dev/
RUN install -dm 755 /etc/apt/keyrings \
    && curl -fsSL https://mise.jdx.dev/gpg-key.pub | gpg --dearmor | tee /etc/apt/keyrings/mise-archive-keyring.gpg 1> /dev/null \
    && echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.gpg arch=$(dpkg --print-architecture)] https://mise.jdx.dev/deb stable main" | tee /etc/apt/sources.list.d/mise.list \
    && apt update \
    && apt install -y mise \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.bashrc \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.zshrc

RUN groupadd sandbox \
    && useradd -g sandbox -m sandbox \
    && mkdir -p /sandbox/tools \
    && chown sandbox:sandbox /sandbox/tools
USER sandbox

# Install Node.js
RUN curl -fsSL "https://nodejs.org/dist/v22.17.1/node-v22.17.1-linux-$(uname -m | sed 's,86_,,').tar.xz" | tar -C /sandbox/tools -xJf - \
    && mv /sandbox/tools/node-v* /sandbox/tools/node \
    && env PATH=/sandbox/tools/node/bin:$PATH npm install -g npm@latest
ENV PATH=/sandbox/tools/node/bin:$PATH

# Install Coding Agents
RUN npm install -g @anthropic-ai/claude-code \
    && npm install -g @google/gemini-cli \
    && rm -rf /home/sandbox/.npm
EOF
}

case "$1" in
  setup_container_firewall | setup_container_user | print_preset_dockerfile )
    "$@"
    ;;
  * )
    main "$@"
esac
