#!/usr/bin/env bash

set -eu -o pipefail

SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
CONTAINER_SCRIPT_PATH="/sandbox/bin/$SCRIPT_NAME"

help() {
  cat << HELP
$SCRIPT_NAME - Run a command in a sandboxed environment

Usage: $SCRIPT_NAME [--dockerfile FILE]
           [--platform PLATFORM]
           [--env-file FILE]
           [--allow-write] [--allow-net [DESTINATIONS]]
           [--use-volume DIRECTORIES]
           [--mount-writable HOST_DIR:CONTAINER_DIR] [--mount-readonly HOST_DIR:CONTAINER_DIR]
           [--publish [[HOST_ADDRESS:]HOST_PORT:]CONTAINER_PORT]
           [--tty]
           [--no-cache]
           [--verbose] [--dry-run]
           COMMAND

Options:
  --dockerfile FILE         Path to the Dockerfile. If not set, a preset Dockerfile is used.
                            The container must include bash, iptables, ip, dnsmasq, and dig commands.
  --env-file FILE           Path to a .env file To load environment variables from.
  --platform                Specify the platform for image building and container execution (e.g., linux/arm64 or linux/amd64).
  --allow-write             Allow write access to the project root inside the container.
                            By default, the project root (git root or current directory) is read-only.
  --allow-net DESTINATIONS  Allow connections to specified domains or IP addresses. Separate multiple destinations with commas.
                            If no port is given, only HTTPS (443) is allowed.
  --use-volume DIRECTORIES  Mount specified directories as volumes inside the container. Separate multiple directories with commas.
                            The volume is mounted at the absolute path of the directory inside the container.
  --mount-readonly HOST_DIR:CONTAINER_DIR
                            Mount a host file or directory to a container path as read-only.
  --mount-writable HOST_DIR:CONTAINER_DIR
                            Mount a host file or directory to a container path as writable.
  --publish [[HOST_ADDRESS:]HOST_PORT:]CONTAINER_PORT
                            Publish container port(s) to the host. If no host address is given, the port binds to 127.0.0.1 by default.
  --tty                     Allocate a pseudo-TTY for the container.
  --no-cache                Don't use cache when building the image.
  --verbose                 Output verbose logs to stderr.
  --dry-run                 Don't execute the command; just print it to stdout.

Examples:
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --tty bash
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --allow-write --allow-net registry.npmjs.org --use-volume node_modules npm install
  $SCRIPT_NAME --dockerfile .agent/sandbox/Dockerfile --verbose --allow-net host.docker.internal:3306 npm run test
HELP
}

print_preset_dockerfile() {
  cat << 'EOF'
FROM debian:12

ARG NODE_VERSION="22.17.1"

RUN apt update && apt install -y \
      busybox \
      bash zsh \
      iptables ipset iproute2 dnsmasq \
      dnsutils iputils-ping netcat-openbsd \
      gpg \
      curl \
      git tig \
      xz-utils

# https://grml.org/zsh/
RUN curl -fsSL https://grml.org/console/zshrc -o /etc/skel/.zshrc \
    && curl -fsSL https://grml.org/console/zshrc.local -o /etc/skel/.zshrc.local \
    && echo 'unsetopt HIST_SAVE_BY_COPY' >> /etc/skel/.zshrc.local

# https://mise.jdx.dev/
RUN install -dm 755 /etc/apt/keyrings \
    && curl -fsSL https://mise.jdx.dev/gpg-key.pub | gpg --dearmor | tee /etc/apt/keyrings/mise-archive-keyring.gpg 1> /dev/null \
    && echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.gpg arch=$(dpkg --print-architecture)] https://mise.jdx.dev/deb stable main" | tee /etc/apt/sources.list.d/mise.list \
    && apt update \
    && apt install -y mise \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.bashrc \
    && echo 'eval "$(mise activate bash)"' >> /etc/skel/.zshrc

RUN groupadd sandbox \
    && useradd -g sandbox -m sandbox \
    && mkdir -p /sandbox/tools \
    && chown sandbox:sandbox /sandbox/tools
USER sandbox

# Install Node.js
RUN curl -fsSL "https://nodejs.org/dist/v${NODE_VERSION}/node-v${NODE_VERSION}-linux-$(uname -m | sed 's,x86_64,x64,; s,aarch64,arm64,').tar.xz" | tar -C /sandbox/tools -xJf - \
    && mv /sandbox/tools/node-v${NODE_VERSION}* /sandbox/tools/node \
    && env PATH=/sandbox/tools/node/bin:$PATH npm install -g npm@latest
ENV PATH=/sandbox/tools/node/bin:$PATH

# Install Coding Agents
RUN npm install -g @anthropic-ai/claude-code \
    && npm install -g ccusage \
    && npm install -g @google/gemini-cli \
    && rm -rf /home/sandbox/.npm

ENV EDITOR="busybox vi"
EOF
}

log() {
  echo "[$(date "+%Y-%m-%d %H:%M:%S%z")][$(hostname)] $*"
}

main() {
  local dockerfile=""
  local allow_write="no"
  local allow_net="no"
  local allow_net_destinations=()
  local volume_dirs=()
  local readonly_mounts=()
  local writable_mounts=()
  local publish_ports=()
  local env_file=""
  local allocate_tty="no"
  local no_cache="no"
  local platform=""

  VERBOSE="no"
  DRY_RUN="no"
  
  while test "$#" -gt 0; do
    case "$1" in
      --help        ) help; return 0 ;;
      --dockerfile  ) dockerfile="$2"; shift 2 ;;
      --platform    ) platform="$2"; shift 2 ;;
      --allow-write ) allow_write="yes"; shift ;;
      --allow-net   )
        allow_net="yes"
        if test -n "$2" && ! grep -q "^--" <<< "$2"; then
          IFS=',' read -r -a allow_net_destinations <<< "$2"
          shift 2
        else
          shift 1
        fi
        ;;
      --use-volume  )
        IFS=',' read -r -a volume_dirs <<< "$2"
        shift 2
        ;;
      --mount-readonly)
        IFS=',' read -r -a readonly_mounts <<< "$2"
        shift 2
        ;;
      --mount-writable)
        IFS=',' read -r -a writable_mounts <<< "$2"
        shift 2
        ;;
      --publish     )
        IFS=',' read -r -a publish_ports <<< "$2"
        shift 2
        ;;
      --env-file    )
        local env_file="$2"
        shift 2
        ;;
      --tty         ) allocate_tty="yes"; shift ;;
      --no-cache    ) no_cache="yes"; shift ;;
      --verbose     ) VERBOSE="yes"; shift ;;
      --dry-run     ) DRY_RUN="yes"; shift ;;
      --            ) shift; continue ;;
      --*           ) echo "Error: unknown option: $1" >&2; return 1 ;;
      *             ) break ;;
    esac
  done
  
  if test "$#" -eq 0; then
    echo "Error: COMMAND is required" >&2
    help >&2
    return 1
  fi

  # save stdout, stderr
  exec 3>&1
  exec 4>&2

  run() {
    if test "$DRY_RUN" = "no"; then
      "$@"
    else
      echo "DRY_RUN: $*" >&3
    fi
  }
 
  if test "$VERBOSE" = "no"; then
    # discard stderr
    exec 2> /dev/null
  fi

  # stdout to stderr
  exec 1>&2

  if test -z "$dockerfile"; then
    log "Dockerfile not specified, using preset."
    "$SCRIPT_PATH" print_preset_dockerfile

    # Persist project files: shell history, .local
    local host_project_persistent_dir=".$SCRIPT_NAME/persistent"
    log "Setting up project persistent directory: $host_project_persistent_dir"

    local host_project_persistent_home_dir="$host_project_persistent_dir/home/sandbox"

    run mkdir -p "$host_project_persistent_home_dir"
    run touch "$host_project_persistent_home_dir/.bash_history"
    run touch "$host_project_persistent_home_dir/.zsh_history"
    run mkdir -p "$host_project_persistent_home_dir/.local"

    writable_mounts+=(
      "$host_project_persistent_home_dir/.bash_history:/home/sandbox/.bash_history"
      "$host_project_persistent_home_dir/.zsh_history:/home/sandbox/.zsh_history"
      "$host_project_persistent_home_dir/.local:/home/sandbox/.local"
    )

    # Persist shared files: .gitconfig, .git-credentials, mise data
    local host_persistent_dir="$HOME/.$SCRIPT_NAME/persistent"
    log "Setting up shared persistent directory: $host_persistent_dir"

    local host_persistent_home_dir="$host_persistent_dir/home/sandbox"
    run mkdir -p "$host_persistent_home_dir"
    if ! test -e "$host_persistent_home_dir/.gitconfig"; then
      if test "$DRY_RUN" = "no"; then
      cat > "$host_persistent_home_dir/.gitconfig" << EOF
[user]
  name = "$(git config --get user.name || true)"
  email = "$(git config --get user.email || true)"
EOF
      else
        echo "DRY_RUN: cat > '$host_persistent_home_dir/.gitconfig' << EOF..."
      fi
    fi
    run mkdir -p "$host_persistent_home_dir/.local/share/mise"

    writable_mounts+=(
      "$host_persistent_home_dir/.gitconfig:/home/sandbox/.gitconfig"
      "$host_persistent_home_dir/.local/share/mise:/home/sandbox/.local/share/mise"
    )

    # allow access to host LLM provider configurations
    run mkdir -p "$HOME/.claude"
    run touch "$HOME/.claude.json"
    run mkdir -p "$HOME/.gemini"

    writable_mounts+=(
      "$HOME/.claude:/home/sandbox/.claude"
      "$HOME/.claude.json:/home/sandbox/.claude.json"
      "$HOME/.gemini:/home/sandbox/.gemini"
    )

    allow_net="yes"
    allow_net_destinations+=(
      # mise
      "mise-versions.jdx.dev"
      "nodejs.org"
      "dl.google.com"

      # Claude Code
      "api.anthropic.com"
      "statsig.anthropic.com"

      # Gemini CLI
      "generativelanguage.googleapis.com"
      "play.googleapis.com"
      "oauth2.googleapis.com"
      "cloudcode-pa.googleapis.com"

      # github
      "github.com"
      "raw.githubusercontent.com"

      # npm
      "registry.npmjs.org"
    )
  fi  

  local host_user_id
  local host_group_id
  host_user_id=$(id -u)
  host_group_id=$(id -g)
  
  # set options
  local host_project_root
  local container_project_root
  local container_workdir
  host_project_root="$(git rev-parse --show-toplevel || pwd)"
  container_project_root="$host_project_root"
  container_workdir=$(pwd)

  local image_name
  local image_tag
  image_name="${SCRIPT_NAME}--$(basename "$(pwd)")"
  image_tag="latest"

  CONTAINER_NAME="${image_name}--$(env LC_CTYPE=C tr -dc '[:alnum:]' < /dev/urandom 2> /dev/null | head -c 10 || true)"
  NETWORK_NAME="${CONTAINER_NAME}"

  local docker_platform_opts=()
  if test -n "$platform"; then
    docker_platform_opts+=(--platform "$platform")
  fi
 
  local docker_build_opts=(--tag "$image_name:$image_tag")
  local docker_build_context=""
  if test -n "$dockerfile"; then
    docker_build_opts+=(--file "$dockerfile")
    docker_build_context=$(dirname "$dockerfile")
  fi

  if test "$no_cache" = "yes"; then
    docker_build_opts+=(--no-cache)
  fi

  local docker_run_opts=(
    --detach
    --name "$CONTAINER_NAME"
    --entrypoint ""
    --user 0:0
    --mount "type=bind,source=${SCRIPT_PATH},target=${CONTAINER_SCRIPT_PATH},readonly"
  )
  
  local docker_exec_opts=(
    --interactive
    --workdir "$container_workdir"
    --user "$host_user_id:$host_group_id"
  )

  if test -n "$env_file"; then
    docker_run_opts+=(--env-file "$env_file")
  fi
  
  if test "$allow_write" = "yes"; then
    docker_run_opts+=(--mount "type=bind,source=${host_project_root},target=${container_project_root}")
  else
    docker_run_opts+=(--mount "type=bind,source=${host_project_root},target=${container_project_root},readonly")
  fi
  
  if test "$allow_net" = "yes"; then
    docker_run_opts+=(
      --cap-add NET_ADMIN
      --cap-add NET_RAW
      --net "$NETWORK_NAME"
      --add-host host.docker.internal:host-gateway
    )
  else
    docker_run_opts+=(--net none)
  fi
  
  # volume options
  for dir in "${volume_dirs[@]}"; do
    volume_name="${image_name}--$(echo "$dir" | sed 's,/,-,g; s,\.,-dot-,g')"
    mount_path="$dir"
    if ! grep -qE "^/" <<< "$mount_path"; then
      if ! test -e "$dir"; then
        mkdir -p "$dir"
      fi
      mount_path="$(readlink -f "${dir}" | sed "s,^${host_project_root},${container_project_root},")"
    fi
    docker_run_opts+=(--mount "type=volume,source=${volume_name},target=${mount_path}")
    log "Setting up volume ownership for $dir ($host_user_id:$host_group_id)."
    run docker run --rm -v "${volume_name}:/mnt" busybox:latest chown "$host_user_id:$host_group_id" /mnt
  done

  # mount options
  for mount in "${readonly_mounts[@]}"; do
    local host_path
    local container_path
    IFS=':' read -r host_path container_path <<< "$mount"
    docker_run_opts+=(--mount "type=bind,source=$(readlink -f "$host_path"),target=${container_path},readonly")
  done
  
  for mount in "${writable_mounts[@]}"; do
    local host_path
    local container_path
    IFS=':' read -r host_path container_path <<< "$mount"
    docker_run_opts+=(--mount "type=bind,source=$(readlink -f "$host_path"),target=${container_path}")
  done

  # publish options
  for port in "${publish_ports[@]}"; do
    if grep -qE '.+:.+:.+' <<< "$port"; then
      # host_address:host_port:container_port
      IFS=':' read -r host_address host_port container_port <<< "$port"
      docker_run_opts+=(--publish "${host_address}:${host_port}:${container_port}")
    elif grep -qE '.+:.+' <<< "$port"; then
      # host_port:container_port
      IFS=':' read -r host_port container_port <<< "$port"
      docker_run_opts+=(--publish "127.0.0.1:${host_port}:${container_port}")
    else
      # # container_port
      docker_run_opts+=(--publish "127.0.0.1::${port}")
    fi
  done
  
  if test "$allocate_tty" = "yes"; then
    docker_exec_opts+=(--tty)
  fi

  on_exit() {
    local exit_status="$?"
  
    if test "$VERBOSE" = "no"; then
      exec 2> /dev/null
    fi
    exec 1>&2
  
    log "Stopping container."
    run docker stop -t 0 "$CONTAINER_NAME" || true
  
    log "Removing container."
    run docker rm -f "$CONTAINER_NAME" || true
  
    if docker network inspect "$NETWORK_NAME" &> /dev/null; then
      log "Removing network."
      run docker network rm "$NETWORK_NAME"
    fi

    exec 3>&-
    exec 4>&-
  
    return "$exit_status"
  }
  
  trap 'on_exit' EXIT

  # shellcheck disable=SC2001
  log "$(cat << EOF
Sandbox Configurations:
  docker_platform_opts=
    $(echo "${docker_platform_opts[*]}" | sed 's, ,\n    ,g')
  docker_build_opts=
    $(echo "${docker_build_opts[*]}" | sed 's, ,\n    ,g')
  docker_build_context=$docker_build_context
  docker_run_opts=
    $(echo "${docker_run_opts[*]}" | sed 's, ,\n    ,g')
  docker_exec_opts=
    $(echo "${docker_exec_opts[*]}" | sed 's, ,\n    ,g')
  command=$@
EOF
  )"

  log "Building docker image."
  if test -n "$dockerfile"; then
    run docker build "${docker_platform_opts[@]}" "${docker_build_opts[@]}" "$docker_build_context"
  else
    run docker build "${docker_platform_opts[@]}" "${docker_build_opts[@]}" - \
      < <("$SCRIPT_PATH" print_preset_dockerfile)
  fi

  if test "$allow_net" = "yes"; then
    log "Creating network."
    run docker network create "$NETWORK_NAME" --driver bridge \
      -o com.docker.network.bridge.enable_ip_masquerade=true
  fi

  log "Inspect container user and group id."
  local container_default_user_group
  local container_default_user_id
  local container_default_group_id
  if test "$DRY_RUN" = "no"; then
    container_default_user_group=$(docker run --rm "${docker_platform_opts[@]}" "${image_name}:${image_tag}" bash -c 'echo $(id -u):$(id -g)')
  else
    container_default_user_group="0:0"
  fi
  container_default_user_id=$(cut -d: -f1 <<< "$container_default_user_group")
  container_default_group_id=$(cut -d: -f2 <<< "$container_default_user_group")
  log "Container default user and group id: $container_default_user_group"
  
  log "Starting container."
  run docker run "${docker_platform_opts[@]}" "${docker_run_opts[@]}" "${image_name}:${image_tag}" \
    "$CONTAINER_SCRIPT_PATH" start_container_dnsmasq

  if test "$allow_net" = "yes"; then
    log "Setting up firewall."
    run docker exec --user 0:0 "$CONTAINER_NAME" \
      "$CONTAINER_SCRIPT_PATH" setup_container_firewall "${allow_net_destinations[@]}"
  fi
  
  log "Setting up container user to match host user ($host_user_id:$host_group_id) for file access."
  run docker exec --user 0:0 "$CONTAINER_NAME" "$CONTAINER_SCRIPT_PATH" setup_container_user \
     "$container_default_user_id" "$container_default_group_id" \
     "$host_user_id" "$host_group_id"
  
  # restore stdout, stderr
  exec 1>&3
  exec 2>&4
  
  run docker exec "${docker_exec_opts[@]}" "$CONTAINER_NAME" "$@"
}

start_container_dnsmasq() {
  local servers=()
  IFS=$'\n' read -r -a servers < <(grep nameserver /etc/resolv.conf | awk '{print $2}')

  mkdir -p /sandbox/etc
  cat > /sandbox/etc/dnsmasq.conf << 'EOF'
log-queries
listen-address=127.0.0.1
EOF
  for server in "${servers[@]}"; do
    echo "server=$server" >> /sandbox/etc/dnsmasq.conf
  done
  echo "nameserver 127.0.0.1" > /etc/resolv.conf

  log "Starting dnsmasq."
  log "/sandbox/etc/dnsmasq.conf"
  cat "/sandbox/etc/dnsmasq.conf"
  log "/etc/resolv.conf"
  cat "/etc/resolv.conf"

  dnsmasq -k -C /sandbox/etc/dnsmasq.conf --log-facility /dev/stdout
}

setup_container_firewall() {
  local destinations=("$@")
  local addresses=()

  local address_pattern='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'
  
  for destination in "${destinations[@]}"; do
    local host="$destination"
    local port=''
    if grep -q ':' <<< "$destination"; then
      host=$(cut -d: -f1 <<< "$destination")
      port=$(cut -d: -f2 <<< "$destination")
    fi

    # address
    if grep -qE "$address_pattern" <<< "$host"; then
      echo "Allow outgoing connections to $destination"
      if test -n "$port"; then
        addresses+=("$host:$port")
      else
        addresses+=("$host")
      fi
      continue
    fi

    # domain
    local domain_address_count=0
    for address in $(getent hosts "$host" | awk '{print $1}'; dig +short A "$host"); do
      if ! grep -qE "$address_pattern" <<< "$address"; then
        log "Warn: Ignore invalid address $address of $host"
        continue
      fi

      if test -n "$port"; then
        log "Allow outgoing connections to $destination $address:$port"
        addresses+=("$address:$port")
      else
        log "Allow outgoing connections to $destination $address"
        addresses+=("$address")
      fi

      domain_address_count=$((domain_address_count + 1))
    done

    if test "$domain_address_count" = 0; then
      echo "Error: Failed to resolve any address for $host" >&2
      return 1
    fi
  done
  
  docker_host_address=$(ip route | grep default | cut -d" " -f3)
  if test -z "$docker_host_address"; then
    echo "Error: Failed to determine docker host address" >&2
    return 1
  fi
  
  # reset
  iptables -F
  iptables -X
  #iptables -t nat -F
  #iptables -t nat -X
  iptables -t mangle -F
  iptables -t mangle -X
  
  # allow dns
  iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
  iptables -A INPUT -p udp --sport 53 -j ACCEPT
  
  # allow localhost
  iptables -A INPUT -i lo -j ACCEPT
  iptables -A OUTPUT -o lo -j ACCEPT
  
  # set default policies
  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT DROP
  
  # allow docker host
  iptables -A INPUT -s "$docker_host_address" -j ACCEPT
  iptables -A OUTPUT -d "$docker_host_address" -j ACCEPT
  
  # allow established connections
  iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
  
  # allow given addresses
  for address in "${addresses[@]}"; do
    if grep -q ':' <<< "$address"; then
      local address_part
      local port
      IFS=':' read -r address_part port <<< "$address"
      iptables -A OUTPUT -d "$address_part" -p tcp --dport "$port" -j ACCEPT
    else
      # allow only HTTPS (443) connections
      iptables -A OUTPUT -d "$address" -p tcp --dport 443 -j ACCEPT
    fi
  done
}

setup_container_user() {
  local container_default_user_id="$1"
  local container_default_group_id="$2"
  local host_user_id="$3"
  local host_group_id="$4"

  local user
  local group
  user=$(getent passwd "$container_default_user_id" | cut -d: -f1 2> /dev/null || echo "")
  group=$(getent group "$container_default_group_id" | cut -d: -f1 2> /dev/null || echo "")

  if test "$container_default_user_id" -eq 0; then
    log "Container default user is root, creating sandbox user/group"
    
    if ! getent group sandbox &> /dev/null; then
      log "Creating group sandbox"
      groupadd sandbox
    fi
    
    if ! getent passwd sandbox &> /dev/null; then
      log "Creating user sandbox"
      useradd -g sandbox -m sandbox
    fi
    
    user="sandbox"
    group="sandbox"
  fi

  log "Updating group '$group' ID to $host_group_id"
  local conflicting_group
  conflicting_group=$(getent group "$host_group_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_group" && test "$conflicting_group" != "$group"; then
    log "Resolving group ID conflict: moving group '$conflicting_group'"
    local temp_gid
    for gid in $(seq 1000 65533); do
      if ! getent group "$gid" &> /dev/null; then
        temp_gid=$gid
        break
      fi
    done
    
    if test -z "$temp_gid"; then
      echo "Error: No available GID in user range" >&2
      return 1
    fi
    
    groupmod -g "$temp_gid" "$conflicting_group"
  fi

  groupmod -g "$host_group_id" "$group"

  log "Updating user '$user' ID to $host_user_id:$host_group_id"
  local conflicting_user
  conflicting_user=$(getent passwd "$host_user_id" | cut -d: -f1 2> /dev/null || echo "")
  if test -n "$conflicting_user" && test "$conflicting_user" != "$user"; then
    log "Resolving user ID conflict: moving user '$conflicting_user'"
    local temp_uid
    for uid in $(seq 1000 65533); do
      if ! getent passwd "$uid" &> /dev/null; then
        temp_uid=$uid
        break
      fi
    done
    
    if test -z "$temp_uid"; then
      echo "Error: No available UID in user range" >&2
      return 1
    fi
    
    usermod -u "$temp_uid" "$conflicting_user"
  fi

  usermod -u "$host_user_id" -g "$host_group_id" "$user"

  # Adjust home directory permissions to match new UID/GID
  local home_dir
  home_dir=$(getent passwd "$user" | cut -d: -f6)
  if test -n "$home_dir" && test -d "$home_dir"; then
    log "Updating home directory ownership: $home_dir"
    chown "$host_user_id:$host_group_id" "$home_dir" || true
  fi

  log "User setup completed: $user ($host_user_id:$host_group_id)"
}

if test "$#" -gt 0; then
  case "$1" in
    start_container_dnsmasq | setup_container_firewall | setup_container_user | print_preset_dockerfile )
      "$@"
      ;;
    * )
      main "$@"
  esac
else
  main
fi
